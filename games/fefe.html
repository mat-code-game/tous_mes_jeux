<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8" />
  <title>Mini Pacâ€‘Man JS</title>
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body {
      min-height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
      font-family: system-ui, sans-serif;
      background: radial-gradient(circle at top, #020617, #0f172a);
      color: #e5e7eb;
    }

    #wrapper {
      text-align: center;
    }

    h1 {
      margin-bottom: 8px;
      font-size: 22px;
      color: #38bdf8;
      letter-spacing: 1px;
    }

    #info {
      font-size: 13px;
      margin-bottom: 10px;
      color: #cbd5f5;
    }

    #score {
      margin-bottom: 8px;
      font-size: 14px;
    }

    #game {
      border-radius: 8px;
      overflow: hidden;
      box-shadow: 0 16px 40px rgba(15,23,42,0.9);
      border: 2px solid #1d4ed8;
      margin: 0 auto;
    }

    canvas {
      background: #020617;
      display: block;
    }

    #message {
      margin-top: 10px;
      font-size: 14px;
      min-height: 18px;
      color: #facc15;
    }
  </style>
</head>
<body>
  <div id="wrapper">
    <h1>Mini Pacâ€‘Man</h1>
    <div id="info">Utilise les flÃ¨ches du clavier pour dÃ©placer Pacâ€‘Man.</div>
    <div id="score">Score : <span id="score-value">0</span></div>
    <div id="game">
      <canvas id="canvas" width="448" height="352"></canvas>
    </div>
    <div id="message"></div>
  </div>

  <script>
    const canvas = document.getElementById("canvas");
    const ctx = canvas.getContext("2d");
    const scoreEl = document.getElementById("score-value");
    const messageEl = document.getElementById("message");

    // 0 : vide, 1 : mur, 2 : pastille
    const map = [
      [1,1,1,1,1,1,1,1,1,1,1,1,1,1],
      [1,2,2,2,1,2,2,2,2,1,2,2,2,1],
      [1,2,1,2,1,2,1,1,2,1,2,1,2,1],
      [1,2,1,2,2,2,2,2,2,2,2,1,2,1],
      [1,2,1,1,1,2,1,1,1,2,1,1,2,1],
      [1,2,2,2,1,2,2,0,2,2,1,2,2,1],
      [1,2,1,2,1,1,2,2,2,1,1,2,1,1],
      [1,2,1,2,2,2,2,2,2,2,2,2,2,1],
      [1,2,1,2,1,1,2,1,1,1,2,1,2,1],
      [1,2,2,2,2,2,2,2,2,2,2,2,2,1],
      [1,1,1,1,1,1,1,1,1,1,1,1,1,1]
    ];

    const tileSize = 32;
    const rows = map.length;
    const cols = map[0].length;

    const pacman = {
      row: 5,
      col: 7,
      dir: { x: 0, y: 0 },
      nextDir: { x: 0, y: 0 },
      radius: tileSize / 2 - 4,
      mouthAngle: 0.25,
      mouthOpening: true
    };

    const ghost = {
      row: 1,
      col: 1,
      color: "#f97316",
      dir: { x: 1, y: 0 },
      stepTimer: 0
    };

    let score = 0;
    let totalDots = 0;
    let gameOver = false;

    // Vitesse (plus grand = plus lent)
    const pacmanStepDelay = 120; // ms entre 2 dÃ©placements de Pac-Man
    let pacmanStepTimer = 0;

    const ghostStepDelay = 260;  // ms entre 2 dÃ©placements du fantÃ´me
    let lastTime = 0;

    function init() {
      totalDots = 0;
      for (let r = 0; r < rows; r++) {
        for (let c = 0; c < cols; c++) {
          if (map[r][c] === 2) totalDots++;
        }
      }
      score = 0;
      scoreEl.textContent = score;
      messageEl.textContent = "";
      gameOver = false;
      pacman.row = 5;
      pacman.col = 7;
      pacman.dir = { x: 0, y: 0 };
      pacman.nextDir = { x: 0, y: 0 };
      ghost.row = 1;
      ghost.col = 1;
      ghost.dir = { x: 1, y: 0 };
      pacmanStepTimer = 0;
      ghost.stepTimer = 0;
    }

    function drawMap() {
      for (let r = 0; r < rows; r++) {
        for (let c = 0; c < cols; c++) {
          const tile = map[r][c];

          ctx.fillStyle = "#020617";
          ctx.fillRect(c * tileSize, r * tileSize, tileSize, tileSize);

          if (tile === 1) {
            ctx.fillStyle = "#1d4ed8";
            ctx.fillRect(c * tileSize + 4, r * tileSize + 4, tileSize - 8, tileSize - 8);
          } else if (tile === 2) {
            ctx.fillStyle = "#e5e7eb";
            ctx.beginPath();
            ctx.arc(
              c * tileSize + tileSize / 2,
              r * tileSize + tileSize / 2,
              4,
              0,
              Math.PI * 2
            );
            ctx.fill();
          }
        }
      }
    }

    function canMoveTo(row, col) {
      if (row < 0 || col < 0 || row >= rows || col >= cols) return false;
      return map[row][col] !== 1;
    }

    function movePacman() {
      const targetRow = pacman.row + pacman.nextDir.y;
      const targetCol = pacman.col + pacman.nextDir.x;
      if (canMoveTo(targetRow, targetCol)) {
        pacman.dir = { ...pacman.nextDir };
      }

      const newRow = pacman.row + pacman.dir.y;
      const newCol = pacman.col + pacman.dir.x;

      if (canMoveTo(newRow, newCol)) {
        pacman.row = newRow;
        pacman.col = newCol;

        if (map[newRow][newCol] === 2) {
          map[newRow][newCol] = 0;
          score++;
          scoreEl.textContent = score;
          totalDots--;
          if (totalDots === 0 && !gameOver) {
            gameOver = true;
            messageEl.textContent = "Bravo ! Tu as mangÃ© toutes les pastilles ðŸŽ‰";
          }
        }
      }
    }

    function updatePacman(delta) {
      pacmanStepTimer += delta;
      if (pacmanStepTimer >= pacmanStepDelay) {
        pacmanStepTimer = 0;
        movePacman();
      }

      // Animation de la bouche
      if (pacman.mouthOpening) {
        pacman.mouthAngle += 0.02;
        if (pacman.mouthAngle >= 0.45) pacman.mouthOpening = false;
      } else {
        pacman.mouthAngle -= 0.02;
        if (pacman.mouthAngle <= 0.1) pacman.mouthOpening = true;
      }
    }

    function drawPacman() {
      const centerX = pacman.col * tileSize + tileSize / 2;
      const centerY = pacman.row * tileSize + tileSize / 2;

      let angleStart = 0;
      let angleEnd = Math.PI * 2;

      if (pacman.dir.x === 1) {
        angleStart = pacman.mouthAngle;
        angleEnd = Math.PI * 2 - pacman.mouthAngle;
      } else if (pacman.dir.x === -1) {
        angleStart = Math.PI + pacman.mouthAngle;
        angleEnd = Math.PI - pacman.mouthAngle;
      } else if (pacman.dir.y === -1) {
        angleStart = -Math.PI / 2 + pacman.mouthAngle;
        angleEnd = Math.PI * 1.5 - pacman.mouthAngle;
      } else if (pacman.dir.y === 1) {
        angleStart = Math.PI / 2 + pacman.mouthAngle;
        angleEnd = Math.PI / 2 - pacman.mouthAngle;
      }

      ctx.fillStyle = "#facc15";
      ctx.beginPath();
      ctx.moveTo(centerX, centerY);
      ctx.arc(centerX, centerY, pacman.radius, angleStart, angleEnd, false);
      ctx.closePath();
      ctx.fill();
    }

    function randomGhostDir(row, col) {
      const dirs = [
        { x: 1, y: 0 },
        { x: -1, y: 0 },
        { x: 0, y: 1 },
        { x: 0, y: -1 }
      ];
      const possible = dirs.filter(d => canMoveTo(row + d.y, col + d.x));
      if (possible.length === 0) return { x: 0, y: 0 };
      return possible[Math.floor(Math.random() * possible.length)];
    }

    function updateGhost(delta) {
      ghost.stepTimer += delta;
      if (ghost.stepTimer >= ghostStepDelay) {
        ghost.stepTimer = 0;
        const newRow = ghost.row + ghost.dir.y;
        const newCol = ghost.col + ghost.dir.x;

        if (!canMoveTo(newRow, newCol) || Math.random() < 0.3) {
          ghost.dir = randomGhostDir(ghost.row, ghost.col);
        } else {
          ghost.row = newRow;
          ghost.col = newCol;
        }
      }

      if (!gameOver && ghost.row === pacman.row && ghost.col === pacman.col) {
        gameOver = true;
        messageEl.textContent = "Oh non ! Le fantÃ´me t'a attrapÃ©. Appuie sur une flÃ¨che pour rejouer.";
      }
    }

    function drawGhost() {
      const x = ghost.col * tileSize + tileSize / 2;
      const y = ghost.row * tileSize + tileSize / 2;
      const r = tileSize / 2 - 4;

      ctx.fillStyle = ghost.color;
      ctx.beginPath();
      ctx.arc(x, y - 4, r, Math.PI, 0);
      ctx.lineTo(x + r, y + r - 6);
      ctx.lineTo(x + r * 0.3, y + r);
      ctx.lineTo(x, y + r - 6);
      ctx.lineTo(x - r * 0.3, y + r);
      ctx.lineTo(x - r, y + r - 6);
      ctx.closePath();
      ctx.fill();

      ctx.fillStyle = "#ffffff";
      ctx.beginPath();
      ctx.arc(x - 6, y - 6, 4, 0, Math.PI * 2);
      ctx.arc(x + 6, y - 6, 4, 0, Math.PI * 2);
      ctx.fill();

      ctx.fillStyle = "#0f172a";
      ctx.beginPath();
      ctx.arc(x - 6, y - 6, 2, 0, Math.PI * 2);
      ctx.arc(x + 6, y - 6, 2, 0, Math.PI * 2);
      ctx.fill();
    }

    function loop(timestamp) {
      const delta = timestamp - lastTime;
      lastTime = timestamp;

      ctx.clearRect(0, 0, canvas.width, canvas.height);
      drawMap();
      updatePacman(delta);
      updateGhost(delta);
      drawPacman();
      drawGhost();

      requestAnimationFrame(loop);
    }

    document.addEventListener("keydown", (e) => {
      if (gameOver) {
        if (["ArrowUp","ArrowDown","ArrowLeft","ArrowRight"].includes(e.key)) {
          init();
        }
      }

      if (e.key === "ArrowLeft") {
        pacman.nextDir = { x: -1, y: 0 };
      } else if (e.key === "ArrowRight") {
        pacman.nextDir = { x: 1, y: 0 };
      } else if (e.key === "ArrowUp") {
        pacman.nextDir = { x: 0, y: -1 };
      } else if (e.key === "ArrowDown") {
        pacman.nextDir = { x: 0, y: 1 };
      }
    });

    init();
    requestAnimationFrame(loop);
  </script>
</body>
</html>
