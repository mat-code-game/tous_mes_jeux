<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8" />
  <title>Neo Snake+</title>
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body {
      background: radial-gradient(circle at top, #111, #000);
      color: #fff;
      font-family: system-ui, sans-serif;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: flex-start;
      min-height: 100vh;
      padding-top: 20px;
    }
    h1 {
      letter-spacing: 2px;
      margin-bottom: 8px;
      text-shadow: 0 0 10px #0ff;
    }
    #info {
      font-size: 14px;
      opacity: 0.8;
      margin-bottom: 10px;
      text-align: center;
    }
    canvas {
      background: linear-gradient(135deg, #050712, #060b1f);
      border-radius: 12px;
      box-shadow: 0 0 25px rgba(0, 255, 255, 0.4);
    }
  </style>
</head>
<body>
  <h1>Neo Snake+</h1>
  <div id="info">
    Flèches ← ↑ → ↓ pour bouger – Entrée pour recommencer<br>
    Pomme rouge = +10 pts | Pomme dorée = +30 pts
  </div>
  <canvas id="game" width="600" height="600"></canvas>

  <script>
    const canvas = document.getElementById("game");
    const ctx = canvas.getContext("2d");

    const W = canvas.width;
    const H = canvas.height;

    const tileCount = 20;
    const tileSize = W / tileCount;

    let snake = [];
    let snakeDir = { x: 1, y: 0 };
    let nextDir = { x: 1, y: 0 };
    let food = { x: 10, y: 10 };

    let specialFood = null;      // pomme dorée
    let specialTimer = 0;        // durée de vie de la pomme dorée

    let obstacles = [];          // blocs à éviter

    let score = 0;
    let bestScore = 0;
    let gameOver = false;

    let moveDelay = 140;
    let lastMoveTime = 0;

    function resetGame() {
      snake = [
        { x: 8, y: 10 },
        { x: 7, y: 10 },
        { x: 6, y: 10 }
      ];
      snakeDir = { x: 1, y: 0 };
      nextDir = { x: 1, y: 0 };
      score = 0;
      gameOver = false;
      moveDelay = 140;
      specialFood = null;
      specialTimer = 0;
      createObstacles();
      placeFood();
    }

    function createObstacles() {
      obstacles = [
        { x: 5, y: 5 },
        { x: 6, y: 5 },
        { x: 13, y: 14 },
        { x: 14, y: 14 },
        { x: 10, y: 3 }
      ];
    }

    function placeFood() {
      let valid = false;
      while (!valid) {
        const x = Math.floor(Math.random() * tileCount);
        const y = Math.floor(Math.random() * tileCount);
        valid =
          !snake.some(seg => seg.x === x && seg.y === y) &&
          !obstacles.some(ob => ob.x === x && ob.y === y);
        if (valid) {
          food.x = x;
          food.y = y;
        }
      }
    }

    function spawnSpecialFood() {
      let valid = false;
      let fx, fy;
      while (!valid) {
        fx = Math.floor(Math.random() * tileCount);
        fy = Math.floor(Math.random() * tileCount);
        valid =
          !snake.some(seg => seg.x === fx && seg.y === fy) &&
          !obstacles.some(ob => ob.x === fx && ob.y === fy) &&
          (fx !== food.x || fy !== food.y);
      }
      specialFood = { x: fx, y: fy };
      specialTimer = 80; // ~80 déplacements
    }

    document.addEventListener("keydown", (e) => {
      if (e.key === "ArrowUp" && snakeDir.y !== 1) {
        nextDir = { x: 0, y: -1 };
      } else if (e.key === "ArrowDown" && snakeDir.y !== -1) {
        nextDir = { x: 0, y: 1 };
      } else if (e.key === "ArrowLeft" && snakeDir.x !== 1) {
        nextDir = { x: -1, y: 0 };
      } else if (e.key === "ArrowRight" && snakeDir.x !== -1) {
        nextDir = { x: 1, y: 0 };
      } else if (e.key === "Enter" && gameOver) {
        resetGame();
      }
    });

    function update(timestamp) {
      if (gameOver) return;

      if (timestamp - lastMoveTime < moveDelay) {
        return;
      }
      lastMoveTime = timestamp;

      snakeDir = nextDir;

      const head = snake[0];
      let newHead = {
        x: head.x + snakeDir.x,
        y: head.y + snakeDir.y
      };

      // Murs qui téléportent
      if (newHead.x < 0) newHead.x = tileCount - 1;
      if (newHead.x >= tileCount) newHead.x = 0;
      if (newHead.y < 0) newHead.y = tileCount - 1;
      if (newHead.y >= tileCount) newHead.y = 0;

      // Collision avec soi-même
      if (snake.some(seg => seg.x === newHead.x && seg.y === newHead.y)) {
        gameOver = true;
        if (score > bestScore) bestScore = score;
        return;
      }

      // Collision avec un obstacle
      if (obstacles.some(ob => ob.x === newHead.x && ob.y === newHead.y)) {
        gameOver = true;
        if (score > bestScore) bestScore = score;
        return;
      }

      snake.unshift(newHead);

      let ateNormal = (newHead.x === food.x && newHead.y === food.y);
      let ateSpecial = specialFood && newHead.x === specialFood.x && newHead.y === specialFood.y;

      if (ateNormal) {
        score += 10;
        if (moveDelay > 70) moveDelay -= 5;
        placeFood();
      }

      if (ateSpecial) {
        score += 30;
        specialFood = null;
        specialTimer = 0;
        if (moveDelay > 60) moveDelay -= 5;
      }

      if (!ateNormal && !ateSpecial) {
        snake.pop();
      }

      if (!gameOver) {
        if (specialFood) {
          specialTimer--;
          if (specialTimer <= 0) {
            specialFood = null;
          }
        } else {
          if (Math.random() < 0.03) {
            spawnSpecialFood();
          }
        }
      }
    }

    function drawBackground() {
      const grad = ctx.createLinearGradient(0, 0, 0, H);
      grad.addColorStop(0, "rgba(0, 255, 255, 0.12)");
      grad.addColorStop(1, "rgba(255, 0, 255, 0.08)");
      ctx.fillStyle = grad;
      ctx.fillRect(0, 0, W, H);

      ctx.globalAlpha = 0.3;
      for (let x = 0; x < tileCount; x++) {
        for (let y = 0; y < tileCount; y++) {
          if ((x + y) % 2 === 0) {
            ctx.fillStyle = "rgba(0,0,0,0.35)";
            ctx.fillRect(x * tileSize, y * tileSize, tileSize, tileSize);
          }
        }
      }
      ctx.globalAlpha = 1;
    }

    function drawSnake() {
      snake.forEach((seg, index) => {
        const px = seg.x * tileSize;
        const py = seg.y * tileSize;

        const t = index / snake.length;
        const r = 0;
        const g = 255;
        const b = 255;
        const brightness = 1 - t * 0.6;

        ctx.save();
        ctx.shadowBlur = 15;
        ctx.shadowColor = `rgba(${r},${g},${b},1)`;
        ctx.fillStyle = `rgba(${r},${g},${b},${brightness})`;
        ctx.fillRect(px + 2, py + 2, tileSize - 4, tileSize - 4);
        ctx.restore();
      });

      const head = snake[0];
      const hx = head.x * tileSize;
      const hy = head.y * tileSize;

      ctx.save();
      ctx.fillStyle = "#000";
      const eyeSize = 4;
      let eye1x, eye1y, eye2x, eye2y;

      if (snakeDir.x === 1) {
        eye1x = hx + tileSize - 8;
        eye1y = hy + 6;
        eye2x = hx + tileSize - 8;
        eye2y = hy + tileSize - 10;
      } else if (snakeDir.x === -1) {
        eye1x = hx + 4;
        eye1y = hy + 6;
        eye2x = hx + 4;
        eye2y = hy + tileSize - 10;
      } else if (snakeDir.y === 1) {
        eye1x = hx + 6;
        eye1y = hy + tileSize - 8;
        eye2x = hx + tileSize - 10;
        eye2y = hy + tileSize - 8;
      } else {
        eye1x = hx + 6;
        eye1y = hy + 4;
        eye2x = hx + tileSize - 10;
        eye2y = hy + 4;
      }

      ctx.fillRect(eye1x, eye1y, eyeSize, eyeSize);
      ctx.fillRect(eye2x, eye2y, eyeSize, eyeSize);
      ctx.restore();
    }

    function drawFood() {
      const fx = food.x * tileSize + tileSize / 2;
      const fy = food.y * tileSize + tileSize / 2;
      const r = tileSize * 0.35;

      ctx.save();
      ctx.shadowBlur = 15;
      ctx.shadowColor = "#f44";
      const g = ctx.createRadialGradient(
        fx, fy, 2,
        fx, fy, r
      );
      g.addColorStop(0, "#fff");
      g.addColorStop(1, "#f44");
      ctx.fillStyle = g;
      ctx.beginPath();
      ctx.arc(fx, fy, r, 0, Math.PI * 2);
      ctx.fill();
      ctx.restore();

      if (specialFood) {
        const sfx = specialFood.x * tileSize + tileSize / 2;
        const sfy = specialFood.y * tileSize + tileSize / 2;
        const r2 = tileSize * 0.35;

        ctx.save();
        ctx.shadowBlur = 20;
        ctx.shadowColor = "#ff0";
        const g2 = ctx.createRadialGradient(
          sfx, sfy, 2,
          sfx, sfy, r2
        );
        g2.addColorStop(0, "#fff");
        g2.addColorStop(1, "#ff0");
        ctx.fillStyle = g2;
        ctx.beginPath();
        ctx.arc(sfx, sfy, r2, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
      }
    }

    function drawObstacles() {
      obstacles.forEach(ob => {
        const x = ob.x * tileSize;
        const y = ob.y * tileSize;
        ctx.save();
        ctx.shadowBlur = 12;
        ctx.shadowColor = "#f0f";
        ctx.fillStyle = "rgba(255,0,255,0.8)";
        ctx.fillRect(x + 2, y + 2, tileSize - 4, tileSize - 4);
        ctx.restore();
      });
    }

    function drawUI() {
      ctx.fillStyle = "#fff";
      ctx.font = "18px system-ui";
      ctx.textAlign = "left";
      ctx.fillText("Score: " + score, 20, 30);
      ctx.fillText("Record: " + bestScore, 20, 55);
      ctx.fillText("Pomme dorée: +30 pts", 20, 80);

      if (gameOver) {
        ctx.fillStyle = "rgba(0,0,0,0.6)";
        ctx.fillRect(0, 0, W, H);
        ctx.fillStyle = "#fff";
        ctx.font = "26px system-ui";
        ctx.textAlign = "center";
        ctx.fillText("GAME OVER", W / 2, H / 2 - 20);
        ctx.font = "18px system-ui";
        ctx.fillText("Score: " + score + " | Record: " + bestScore, W / 2, H / 2 + 10);
        ctx.fillText("Appuie sur ENTRÉE pour rejouer", W / 2, H / 2 + 40);
      }
    }

    function loop(timestamp) {
      update(timestamp);
      drawBackground();
      drawFood();
      drawObstacles();
      drawSnake();
      drawUI();
      requestAnimationFrame(loop);
    }

    resetGame();
    requestAnimationFrame(loop);
  </script>
</body>
</html>
