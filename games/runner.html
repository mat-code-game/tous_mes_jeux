<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8" />
  <title>Geometry Runner – Niveaux (clic souris)</title>
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body {
      background: radial-gradient(circle at top, #111, #000);
      color: #fff;
      font-family: system-ui, sans-serif;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: flex-start;
      min-height: 100vh;
      padding-top: 20px;
    }
    h1 {
      letter-spacing: 2px;
      margin-bottom: 8px;
      text-shadow: 0 0 10px rgba(238, 255, 0, 0.705);
    }
    #info {
      font-size: 14px;
      opacity: 0.8;
      margin-bottom: 10px;
      text-align: center;
    }
    canvas {
      background: linear-gradient(135deg, #050712, #060b1f);
      border-radius: 12px;
      box-shadow: 0 0 25px rgba(200, 255, 0, 0.4);
      cursor: pointer;
    }
  </style>
</head>
<body>

  <button id="fullscreenBtn">Plein écran</button>

  <h1>Geometry Runner – Niveaux</h1>
  <div id="info">
    Clic gauche = saut (double saut) • Termine le niveau pour passer au suivant
  </div>
  <canvas id="game" width="900" height="400"></canvas>

  <script>
    const canvas = document.getElementById("game");
    const ctx = canvas.getContext("2d");

    const W = canvas.width;
    const H = canvas.height;
    const groundY = H - 80;

    const player = {
      x: 120,
      y: groundY - 40,
      w: 40,
      h: 40,
      vy: 0,
      gravity: 0.8,
      jumpPower: 16,
      jumpsLeft: 2,
      angle: 0
    };

    let spikes = [];
    let platforms = [];

    let baseSpeed = 6;
    let gameSpeed = baseSpeed;
    let score = 0;
    let bestScore = 0;
    let started = false;
    let gameOver = false;
    let levelFinished = false;

    let currentLevel = 0;

    const tile = 80;

    const LEVELS = [
      {
        name: "Niveau 1",
        baseSpeed: 6,
        spikePattern: [
          0,0,1,0, 0,1,0,0,
          0,0,1,1, 0,0,0,0,
          0,1,0,1, 0,0,0,0,
          1,0,0,1, 0,0,0,0,
          0,0,0,0, 0,0,0,0
        ],
        platformPattern: [
          0,0,0,0,  0,0,0,0,
          0,0,0,0,  1,0,0,0,
          0,0,0,0,  0,1,0,0,
          0,0,0,0,  0,0,0,0,
          0,0,0,0,  0,0,0,0
        ]
      },
      {
        name: "Niveau 2",
        baseSpeed: 6.5,
        spikePattern: [
          0,0,1,0,  0,0,1,0,
          0,0,0,1,  0,0,0,1,
          0,1,0,0,  0,1,0,0,
          0,0,1,0,  0,0,1,0,
          0,0,0,0,  0,0,0,0
        ],
        platformPattern: [
          0,0,0,0,  0,0,0,0,
          0,0,0,0,  1,0,0,0,
          0,0,0,0,  0,1,0,0,
          0,0,0,0,  0,0,0,0,
          0,0,0,0,  0,0,0,0
        ]
      },
      {
        name: "Niveau 3",
        baseSpeed: 8,
        spikePattern: [
          1,0,0,0,  1,0,1,0,
          0,0,1,0,  0,1,0,0,
          1,0,1,1,  1,0,1,0,
          0,0,1,0,  0,1,0,0,
          0,0,0,0,  0,0,0,0
        ],
        platformPattern: [
          0,0,0,0,  0,1,1,1,
          1,1,1,1,  1,0,1,1,
          0,1,0,0,  1,1,1,0,
          1,1,0,1,  1,1,1,1,
          1,1,1,1,  1,1,1,1
        ]
      }
      ,
      {
        name: "Niveau 4",
        baseSpeed: 8,
        spikePattern: [
          1,0,0,0,  1,0,1,0,
          0,0,1,0,  0,1,0,0,
          1,0,1,1,  1,0,1,0,
          0,0,1,0,  0,1,0,0,
          0,0,0,0,  0,0,0,0
        ],
        platformPattern: [
          0,0,0,0,  0,1,0,0,
          1,0,0,0,  1,0,0,1,
          0,1,0,0,  1,0,0,0,
          1,1,0,1,  1,1,1,1,
          1,1,1,1,  1,1,1,1
        ]
      }
      ,{
       name: "Niveau 5",
        baseSpeed: 8,
        spikePattern: [
          1,0,0,1,  0,1,1,0,
          0,0,1,0,  0,1,0,0,
          1,0,1,0,  1,0,0,1,
          0,0,1,0,  0,1,0,0,
          0,0,0,0,  0,0,0,0
        ],
        platformPattern: [
          0,0,0,0,  0,0,0,1,
          0,0,1,0,  0,1,1,1,
          0,0,0,0,  1,0,0,0,
          0,0,0,1,  0,0,0,0,
          1,1,1,1,  1,1,1,1
        ]
      }
    ];




    // Contrôles : clic souris sur le canvas
    canvas.addEventListener("mousedown", () => {
      if (!started) {
        started = true;
        resetGame(true);
      } else if (!gameOver && !levelFinished && player.jumpsLeft > 0) {
        player.vy = -player.jumpPower;
        player.jumpsLeft--;
      } else if (gameOver) {
        resetGame(true);
      } else if (levelFinished) {
        nextLevel();
      }
    });

    function resetGame(resetLevelIndex) {
      if (resetLevelIndex) {
        currentLevel = 0;
      }
      const level = LEVELS[currentLevel];
      baseSpeed = level.baseSpeed;
      gameSpeed = baseSpeed;
      player.y = groundY - player.h;
      player.vy = 0;
      player.jumpsLeft = 2;
      player.angle = 0;
      score = 0;
      gameOver = false;
      levelFinished = false;
      createLevelFromPattern(level);
    }

    function nextLevel() {
      if (currentLevel < LEVELS.length - 1) {
        currentLevel++;
      } else {
        currentLevel = 0;
      }
      resetGame(false);
    }

     // Fonction pour passer en plein écran
  function openFullscreen(element) {
    if (element.requestFullscreen) {
      element.requestFullscreen();
    } else if (element.webkitRequestFullscreen) { // Safari
      element.webkitRequestFullscreen();
    } else if (element.msRequestFullscreen) { // IE/Edge
      element.msRequestFullscreen();
    }
  }

  // Fonction pour quitter le plein écran
  function closeFullscreen() {
    if (document.exitFullscreen) {
      document.exitFullscreen();
    } else if (document.webkitExitFullscreen) { // Safari
      document.webkitExitFullscreen();
    } else if (document.msExitFullscreen) { // IE/Edge
      document.msExitFullscreen();
    }
  }

  // Quand la page est chargée
  window.addEventListener('DOMContentLoaded', () => {
    const fsBtn = document.getElementById('fullscreenBtn');

    // Choisis l'élément à mettre en plein écran
    // Si ton jeu est dans un canvas :
    // const element = document.querySelector('canvas');
    // Si tu as un conteneur <div id="game"> :
    // const element = document.getElementById('game');
    // Ici on met toute la page :
    const element = document.documentElement;

    fsBtn.addEventListener('click', () => {
      const isFullscreen =
        document.fullscreenElement ||
        document.webkitFullscreenElement ||
        document.msFullscreenElement;

      if (!isFullscreen) {
        openFullscreen(element);
        fsBtn.textContent = 'Quitter plein écran';
      } else {
        closeFullscreen();
        fsBtn.textContent = 'Plein écran';
      }
    });

    // Met à jour le texte si l'utilisateur sort du plein écran avec Échap
    document.addEventListener('fullscreenchange', () => {
      if (
        !document.fullscreenElement &&
        !document.webkitFullscreenElement &&
        !document.msFullscreenElement
      ) {
        fsBtn.textContent = 'Plein écran';
      }
    });
  });

    function createLevelFromPattern(level) {
      spikes = [];
      platforms = [];
      const baseX = 0;

      for (let i = 0; i < level.spikePattern.length; i++) {
        const xBase = baseX + W + i * tile;

        if (level.spikePattern[i] === 1) {
          spikes.push(makeSpike(xBase + tile / 2, groundY, 40));
        }

        if (level.platformPattern[i] === 1) {
          const pw = tile;
          const ph = 20;
          const py = groundY - 120;
          platforms.push({
            x: xBase,
            y: py,
            w: pw,
            h: ph
          });
        }
      }
    }

    function makeSpike(baseX, baseY, height) {
      const halfWidth = 20;
      return {
        x1: baseX - halfWidth,
        y1: baseY,
        x2: baseX + halfWidth,
        y2: baseY,
        x3: baseX,
        y3: baseY - height
      };
    }

    function triangleAABBIntersect(spike, px, py, pw, ph) {
      const minX = Math.min(spike.x1, spike.x2, spike.x3);
      const maxX = Math.max(spike.x1, spike.x2, spike.x3);
      const minY = Math.min(spike.y1, spike.y2, spike.y3);
      const maxY = Math.max(spike.y1, spike.y2, spike.y3);

      const overlap =
        px < maxX &&
        px + pw > minX &&
        py < maxY &&
        py + ph > minY;

      return overlap;
    }

    function update(timestamp) {
      if (!started || gameOver || levelFinished) return;

      player.vy += player.gravity;
      player.y += player.vy;

      let onSomething = false;

      if (player.y >= groundY - player.h) {
        player.y = groundY - player.h;
        player.vy = 0;
        onSomething = true;
      }

      const px = player.x;
      const py = player.y;
      const pw = player.w;
      const ph = player.h;

      platforms.forEach(plat => {
        const prevBottom = py + ph - player.vy;
        const currentBottom = py + ph;

        if (
          px + pw > plat.x &&
          px < plat.x + plat.w &&
          prevBottom <= plat.y &&
          currentBottom >= plat.y
        ) {
          player.y = plat.y - ph;
          player.vy = 0;
          onSomething = true;
        }
      });

      if (onSomething) {
        player.jumpsLeft = 2;
      }

      score += 1;

      spikes.forEach(sp => {
        sp.x1 -= gameSpeed;
        sp.x2 -= gameSpeed;
        sp.x3 -= gameSpeed;
      });

      platforms.forEach(plat => {
        plat.x -= gameSpeed;
      });

      spikes = spikes.filter(sp => sp.x2 > -50);
      platforms = platforms.filter(plat => plat.x + plat.w > -50);

      for (let sp of spikes) {
        if (triangleAABBIntersect(sp, px, py, pw, ph)) {
          gameOver = true;
          if (score > bestScore) bestScore = score;
          break;
        }
      }

      if (!onSomething) {
        player.angle += 0.25;
      } else {
        player.angle = 0;
      }

      if (spikes.length === 0 && !gameOver) {
        gameSpeed = 0;
        levelFinished = true;
        if (score > bestScore) bestScore = score;
      }
    }

    function drawBackground() {
      const grad = ctx.createLinearGradient(0, 0, 0, H);
      grad.addColorStop(0, "rgba(0, 255, 255, 0.12)");
      grad.addColorStop(1, "rgba(255, 0, 255, 0.08)");
      ctx.fillStyle = grad;
      ctx.fillRect(0, 0, W, H);
    }

    function drawGround() {
      ctx.strokeStyle = "rgba(255,255,255,0.4)";
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.moveTo(0, groundY);
      ctx.lineTo(W, groundY);
      ctx.stroke();
    }

    function drawPlatforms() {
      platforms.forEach(plat => {
        ctx.save();
        ctx.shadowBlur = 15;
        ctx.shadowColor = "#0f0";
        ctx.fillStyle = "rgba(0,255,0,0.8)";
        ctx.fillRect(plat.x, plat.y, plat.w, plat.h);
        ctx.restore();
      });
    }

    function drawSpikes() {
      spikes.forEach(ob => {
        ctx.save();
        ctx.shadowBlur = 18;
        ctx.shadowColor = "#f44";
        ctx.fillStyle = "#f44";
        ctx.beginPath();
        ctx.moveTo(ob.x1, ob.y1);
        ctx.lineTo(ob.x2, ob.y2);
        ctx.lineTo(ob.x3, ob.y3);
        ctx.closePath();
        ctx.fill();
        ctx.restore();
      });
    }

    function drawPlayer() {
      ctx.save();
      ctx.translate(player.x + player.w / 2, player.y + player.h / 2);
      ctx.rotate(player.angle);
      ctx.translate(-player.w / 2, -player.h / 2);

      ctx.shadowBlur = 18;
      ctx.shadowColor = "#f44";
      ctx.fillStyle = "rgba(0,255,0,0.8)";
      ctx.fillRect(0, 0, player.w, player.h);

      ctx.fillStyle = "#000";
      ctx.shadowBlur = 0;
      ctx.fillRect(8, 10, 6, 6);
      ctx.fillRect(player.w - 14, 10, 6, 6);

      ctx.restore();
    }

    function drawUI() {
      const level = LEVELS[currentLevel];

      ctx.fillStyle = "#fff";
      ctx.font = "18px system-ui";
      ctx.textAlign = "left";
      ctx.fillText("Score: " + score, 20, 30);
      ctx.fillText("Record: " + bestScore, 20, 55);
      ctx.fillText("Sauts restants: " + player.jumpsLeft, 20, 80);

      ctx.textAlign = "right";
      ctx.fillText(level.name + " (" + (currentLevel + 1) + "/" + LEVELS.length + ")", W - 20, 30);

      if (!started) {
        ctx.fillStyle = "rgba(0,0,0,0.6)";
        ctx.fillRect(0, 0, W, H);
        ctx.fillStyle = "#fff";
        ctx.font = "24px system-ui";
        ctx.textAlign = "center";
        ctx.fillText("Clique sur le jeu pour commencer", W / 2, H / 2);
      } else if (gameOver) {
        ctx.fillStyle = "rgba(0,0,0,0.6)";
        ctx.fillRect(0, 0, W, H);
        ctx.fillStyle = "#fff";
        ctx.font = "26px system-ui";
        ctx.textAlign = "center";
        ctx.fillText("GAME OVER", W / 2, H / 2 - 20);
        ctx.font = "18px system-ui";
        ctx.fillText("Score: " + score + " | Record: " + bestScore, W / 2, H / 2 + 10);
        ctx.fillText("Clique pour recommencer au Niveau 1", W / 2, H / 2 + 40);
      } else if (levelFinished) {
        ctx.fillStyle = "rgba(0,0,0,0.6)";
        ctx.fillRect(0, 0, W, H);
        ctx.fillStyle = "#0f0";
        ctx.font = "26px system-ui";
        ctx.textAlign = "center";
        ctx.fillText(level.name + " terminé !", W / 2, H / 2 - 20);
        ctx.font = "18px system-ui";
        if (currentLevel < LEVELS.length - 1) {
          ctx.fillText("Clique pour passer au niveau suivant", W / 2, H / 2 + 10);
        } else {
          ctx.fillText("Tous les niveaux sont finis ! Clique pour recommencer", W / 2, H / 2 + 10);
        }
      }
    }

    function draw() {
      ctx.clearRect(0, 0, W, H);
      drawBackground();
      drawGround();
      drawPlatforms();
      drawSpikes();
      drawPlayer();
      drawUI();
    }

    function loop(timestamp) {
      update(timestamp);
      draw();
      requestAnimationFrame(loop);
    }

    resetGame(true);
    requestAnimationFrame(loop);
  </script>
</body>
</html>
