<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8">
  <title>Course Évite-voitures PRO+</title>
  <style>
    body {
      margin: 0;
      background: #111;
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100vh;
      font-family: Arial, sans-serif;
      color: white;
    }
    #gameCanvas {
      background: #333;
      border: 3px solid #fff;
    }
    #hud {
      position: absolute;
      top: 10px;
      left: 10px;
      background: rgba(0,0,0,0.5);
      padding: 6px 10px;
      border-radius: 4px;
      font-size: 14px;
    }
    #hud span { margin-right: 10px; }
  </style>
</head>
<body>
  <canvas id="gameCanvas" width="400" height="600"></canvas>
  <div id="hud">
    <span>Score : <strong id="score">0</strong></span>
    <span>Vies : <strong id="lives">3</strong></span>
    <span>Best : <strong id="best">0</strong></span>
    <span id="state" style="color:orange;"></span>
  </div>
  <button id="fullscreenBtn">Plein écran</button>


  <!-- SONS -->
  <audio id="sndCrash" src="sf_avion_crash.mp3" preload="auto"></audio>
  <audio id="sndBonus" src="bonus.mp3" preload="auto"></audio>

  <script>
    
    const canvas = document.getElementById("gameCanvas");
    const ctx = canvas.getContext("2d");
    const scoreEl = document.getElementById("score");
    const livesEl = document.getElementById("lives");
    const bestEl  = document.getElementById("best");
    const stateEl = document.getElementById("state");

    const sndCrash = document.getElementById("sndCrash");
    const sndBonus = document.getElementById("sndBonus");

    const roadWidth = 260;
    const roadX = (canvas.width - roadWidth) / 2;

    const player = { w: 40, h: 70, x: 0, y: 0, speed: 6 };
    const enemies = [];
    const bonuses = [];
    const particles = [];

    let enemySpeed, spawnTimer, spawnInterval, score, lives;
    let running, paused, started, last;
    let difficulty = "normal"; // easy, normal, hard
    let bestScore = 0;

    const stored = localStorage.getItem("eviteVoituresBest");
    if (stored !== null) {
      bestScore = parseInt(stored, 10) || 0;
    }
    bestEl.textContent = bestScore;

    const keys = {};
    window.addEventListener("keydown", e => {
      keys[e.key] = true;

      if (e.key === "r" || e.key === "R") {
        if (!running) resetGame();
      }
      if (e.key === "p" || e.key === "P") {
        if (running) {
          paused = !paused;
          stateEl.textContent = paused ? "PAUSE (P pour reprendre)" : "";
        }
      }
      if (e.key === "ArrowUp" && !started) {
        started = true;
        stateEl.textContent = "";
      }

      if (!started && !running) {
        if (e.key === "1") { difficulty = "easy";   stateEl.textContent = "Mode FACILE (1)"; }
        if (e.key === "2") { difficulty = "normal"; stateEl.textContent = "Mode NORMAL (2)"; }
        if (e.key === "3") { difficulty = "hard";   stateEl.textContent = "Mode DIFFICILE (3)"; }
      }
    });
    window.addEventListener("keyup", e => keys[e.key] = false);

    function applyDifficultyBase() {
      if (difficulty === "easy") {
        enemySpeed    = 2.5;
        spawnInterval = 1.4;
        player.speed  = 7;
      } else if (difficulty === "hard") {
        enemySpeed    = 3.8;
        spawnInterval = 0.9;
        player.speed  = 6;
      } else {
        enemySpeed    = 3.2;
        spawnInterval = 1.2;
        player.speed  = 6.5;
      }
    }

     // Fonction pour passer en plein écran
  function openFullscreen(element) {
    if (element.requestFullscreen) {
      element.requestFullscreen();
    } else if (element.webkitRequestFullscreen) { // Safari
      element.webkitRequestFullscreen();
    } else if (element.msRequestFullscreen) { // IE/Edge
      element.msRequestFullscreen();
    }
  }

  // Fonction pour quitter le plein écran
  function closeFullscreen() {
    if (document.exitFullscreen) {
      document.exitFullscreen();
    } else if (document.webkitExitFullscreen) { // Safari
      document.webkitExitFullscreen();
    } else if (document.msExitFullscreen) { // IE/Edge
      document.msExitFullscreen();
    }
  }

  // Quand la page est chargée
  window.addEventListener('DOMContentLoaded', () => {
    const fsBtn = document.getElementById('fullscreenBtn');

    // Choisis l'élément à mettre en plein écran
    // Si ton jeu est dans un canvas :
    // const element = document.querySelector('canvas');
    // Si tu as un conteneur <div id="game"> :
    // const element = document.getElementById('game');
    // Ici on met toute la page :
    const element = document.documentElement;

    fsBtn.addEventListener('click', () => {
      const isFullscreen =
        document.fullscreenElement ||
        document.webkitFullscreenElement ||
        document.msFullscreenElement;

      if (!isFullscreen) {
        openFullscreen(element);
        fsBtn.textContent = 'Quitter plein écran';
      } else {
        closeFullscreen();
        fsBtn.textContent = 'Plein écran';
      }
    });

    // Met à jour le texte si l'utilisateur sort du plein écran avec Échap
    document.addEventListener('fullscreenchange', () => {
      if (
        !document.fullscreenElement &&
        !document.webkitFullscreenElement &&
        !document.msFullscreenElement
      ) {
        fsBtn.textContent = 'Plein écran';
      }
    });
  });

    function resetGame() {
      player.x = canvas.width / 2 - player.w / 2;
      player.y = canvas.height - 90;
      enemies.length = 0;
      bonuses.length = 0;
      particles.length = 0;
      spawnTimer = 0;
      score = 0;
      lives = 3;
      running = true;
      paused = false;
      started = false;
      applyDifficultyBase();
      stateEl.textContent = "↑ pour démarrer | 1:F 2:N 3:D";
      last = performance.now();
      scoreEl.textContent = score;
      livesEl.textContent = lives;
    }

    function spawnEnemy() {
      const laneWidth = 60;
      const lanes = 3;
      const laneIndex = Math.floor(Math.random() * lanes);
      const ex = roadX + laneWidth/2 + laneIndex*laneWidth - 20;
      enemies.push({ x: ex, y: -80, w: 40, h: 70 });
    }

    function spawnBonus() {
      const laneWidth = 60;
      const lanes = 3;
      const laneIndex = Math.floor(Math.random() * lanes);
      const bx = roadX + laneWidth/2 + laneIndex*laneWidth - 15;
      bonuses.push({ x: bx, y: -40, w: 30, h: 30 });
    }

    function rectIntersect(a, b) {
      return !(
        a.x + a.w < b.x ||
        a.x > b.x + b.w ||
        a.y + a.h < b.y ||
        a.y > b.y + b.h
      );
    }

    function createExplosion(x, y) {
      for (let i = 0; i < 25; i++) {
        const angle = Math.random() * Math.PI * 2;
        const speed = 2 + Math.random() * 3;
        particles.push({
          x, y,
          vx: Math.cos(angle) * speed,
          vy: Math.sin(angle) * speed,
          radius: 2 + Math.random() * 2,
          alpha: 1
        });
      }
    }

    function playSound(sound) {
      sound.currentTime = 0;
      sound.play();
    }

    function update(dt) {
      if (!running || paused || !started) return;

      if (keys["ArrowLeft"])  player.x -= player.speed;
      if (keys["ArrowRight"]) player.x += player.speed;

      const minX = roadX + 10;
      const maxX = roadX + roadWidth - player.w - 10;
      if (player.x < minX) player.x = minX;
      if (player.x > maxX) player.x = maxX;

      const speedBonus = Math.min(3, score / 200);
      const spawnBonusFactor = Math.min(0.5, score / 500);
      const currentSpawnInterval = Math.max(0.4, spawnInterval - spawnBonusFactor);

      spawnTimer += dt;
      if (spawnTimer > currentSpawnInterval) {
        spawnTimer = 0;
        spawnEnemy();
        if (Math.random() < 0.25) spawnBonus();
      }

      for (const e of enemies) e.y += enemySpeed + speedBonus;
      for (let i = enemies.length - 1; i >= 0; i--) {
        if (enemies[i].y > canvas.height + 80) {
          enemies.splice(i, 1);
          score += 10;
        }
      }

      for (const b of bonuses) b.y += (enemySpeed + speedBonus) * 0.8;
      for (let i = bonuses.length - 1; i >= 0; i--) {
        if (bonuses[i].y > canvas.height + 40) {
          bonuses.splice(i, 1);
        }
      }

      for (let i = enemies.length - 1; i >= 0; i--) {
        const e = enemies[i];
        if (rectIntersect(player, e)) {
          enemies.splice(i, 1);
          lives--;
          createExplosion(player.x + player.w/2, player.y + player.h/2);
          playSound(sndCrash); // son de collision
          if (lives <= 0) {
            running = false;
            stateEl.textContent = "GAME OVER (R pour rejouer)";
            if (score > bestScore) {
              bestScore = score;
              localStorage.setItem("eviteVoituresBest", bestScore);
              bestEl.textContent = bestScore;
            }
          }
        }
      }

      for (let i = bonuses.length - 1; i >= 0; i--) {
        const b = bonuses[i];
        if (rectIntersect(player, b)) {
          bonuses.splice(i, 1);
          lives++;
          score += 20;
          playSound(sndBonus); // son de bonus
        }
      }

      for (let i = particles.length - 1; i >= 0; i--) {
        const p = particles[i];
        p.x += p.vx;
        p.y += p.vy;
        p.alpha -= 0.03;
        if (p.alpha <= 0) particles.splice(i, 1);
      }

      scoreEl.textContent = score;
      livesEl.textContent = lives;
    }

    function drawRoad() {
      ctx.fillStyle = "#222";
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      ctx.fillStyle = "#555";
      ctx.fillRect(roadX, 0, roadWidth, canvas.height);

      ctx.fillStyle = "#fff";
      ctx.fillRect(roadX - 5, 0, 5, canvas.height);
      ctx.fillRect(roadX + roadWidth, 0, 5, canvas.height);

      ctx.strokeStyle = "#fff";
      ctx.setLineDash([20, 20]);
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.moveTo(canvas.width/2, 0);
      ctx.lineTo(canvas.width/2, canvas.height);
      ctx.stroke();
      ctx.setLineDash([]);
    }

    function drawPlayer() {
      ctx.fillStyle = "#00BFFF";
      ctx.fillRect(player.x, player.y, player.w, player.h);
      ctx.fillStyle = "#000";
      ctx.fillRect(player.x + 8, player.y + 10, 24, 16);
    }

    function drawEnemies() {
      for (const e of enemies) {
        ctx.fillStyle = "#FF4444";
        ctx.fillRect(e.x, e.y, e.w, e.h);
        ctx.fillStyle = "#000";
        ctx.fillRect(e.x + 8, e.y + 10, 24, 16);
      }
    }

    function drawBonuses() {
      for (const b of bonuses) {
        ctx.fillStyle = "#00FF66";
        ctx.fillRect(b.x, b.y, b.w, b.h);
        ctx.fillStyle = "#fff";
        ctx.font = "20px Arial";
        ctx.fillText("+1", b.x + 3, b.y + 22);
      }
    }

    function drawParticles() {
      for (const p of particles) {
        ctx.save();
        ctx.globalAlpha = p.alpha;
        ctx.fillStyle = "orange";
        ctx.beginPath();
        ctx.arc(p.x, p.y, p.radius, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
      }
    }

    function loop(now) {
      const dt = (now - last) / 1000;
      last = now;

      update(dt);
      drawRoad();
      drawPlayer();
      drawEnemies();
      drawBonuses();
      drawParticles();

      requestAnimationFrame(loop);
    }

    resetGame();
    requestAnimationFrame(loop);
  </script>
</body>
</html>
